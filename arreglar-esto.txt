Keywords especÃ­ficas para cada grupo
URL especÃ­fica para cada grupo
Y todo eso respetando la configuraciÃ³n avanzada (creatividad, keywords por grupo, etc.) y publicando directamente vÃ­a Google Ads API.

AquÃ­ estÃ¡ la correcciÃ³n del TAB AUTOPILOT con esta funcionalidad:

Python
def render_autopilot_tab():
    """Renderiza la pestaÃ±a AUTOPILOT 2050 con mÃºltiples grupos de anuncios"""
    
    # CSS futurÃ­stico (igual que antes)
    st.markdown("""
    <style>
        .autopilot-header {
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            padding: 3rem;
            border-radius: 20px;
            text-align: center;
            color: #00ffff;
            margin-bottom: 2rem;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            border: 2px solid #00ffff;
        }
        .neural-card {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%);
            border: 1px solid #00ffff;
            border-radius: 15px;
            padding: 2rem;
            margin: 1rem 0;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            color: #ffffff;
        }
        .neural-card h3 {
            color: #00ffff;
            font-family: 'Courier New', monospace;
        }
        .group-box {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1rem 0;
        }
    </style>
    """, unsafe_allow_html=True)
    
    # Header
    st.markdown("""
    <div class="autopilot-header">
        <h1>ğŸ¤– AUTOPILOT 2050</h1>
        <div class="autopilot-subtitle" style="font-size: 1.2rem; margin-top: 1rem; opacity: 0.8; font-family: 'Courier New', monospace;">
            Autopublicador Inteligente Multi-Grupo
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    # Importar servicios
    try:
        from services.intelligent_autopilot import IntelligentAutopilot
        
        google_ads_client = st.session_state.get('google_ads_client')
        if not google_ads_client:
            st.error("âŒ Cliente de Google Ads no inicializado")
            return
        
        intelligent_autopilot = IntelligentAutopilot(google_ads_client)
    except ImportError as e:
        st.error(f"âŒ Error importando servicios: {e}")
        return
    
    # Verificar customer
    if 'selected_customer' not in st.session_state or not st.session_state.selected_customer:
        st.warning("âš ï¸ Selecciona un cliente primero")
        return
    
    selected_customer = st.session_state.selected_customer
    
    st.markdown("---")
    
    # PASO 1: Modo de campaÃ±a
    st.markdown("""
    <div class="neural-card">
        <h3>ğŸ¯ PASO 1: MODO DE CAMPAÃ‘A</h3>
    </div>
    """, unsafe_allow_html=True)
    
    campaign_mode = st.radio(
        "Selecciona el modo:",
        ["ğŸ†• Crear Nueva CampaÃ±a", "ğŸ“‹ Usar CampaÃ±a Existente"]
    )
    
    st.markdown("---")
    
    # PASO 2: ConfiguraciÃ³n segÃºn modo
    if campaign_mode == "ğŸ“‹ Usar CampaÃ±a Existente":
        st.markdown("""
        <div class="neural-card">
            <h3>ğŸ“‹ PASO 2: SELECCIONAR CAMPAÃ‘A</h3>
        </div>
        """, unsafe_allow_html=True)
        
        with st.spinner("ğŸ” Detectando campaÃ±as..."):
            try:
                available_campaigns = intelligent_autopilot.get_available_campaigns(selected_customer)
                
                if not available_campaigns:
                    st.warning("âš ï¸ No hay campaÃ±as. Usa 'Crear Nueva'")
                    return
                
                campaign_options = []
                for campaign in available_campaigns:
                    if not campaign.is_new:
                        status_icon = "ğŸŸ¢" if campaign.campaign_status == "ENABLED" else "ğŸŸ¡"
                        campaign_options.append(f"{status_icon} {campaign.campaign_name} (ID: {campaign.campaign_id})")
                
                if not campaign_options:
                    st.warning("âš ï¸ No hay campaÃ±as vÃ¡lidas")
                    return
                
                selected_campaign_display = st.selectbox("CampaÃ±a:", campaign_options)
                selected_campaign_id = selected_campaign_display.split("ID: ")[1].split(")")[0]
                selected_campaign_obj = next(c for c in available_campaigns if c.campaign_id == selected_campaign_id)
                
                st.success(f"âœ… CampaÃ±a seleccionada: **{selected_campaign_obj.campaign_name}**")
                
            except Exception as e:
                st.error(f"âŒ Error: {e}")
                return
    
    else:  # Nueva campaÃ±a
        st.markdown("""
        <div class="neural-card">
            <h3>ğŸ†• PASO 2: NUEVA CAMPAÃ‘A</h3>
        </div>
        """, unsafe_allow_html=True)
        
        col1, col2 = st.columns(2)
        with col1:
            campaign_name = st.text_input("ğŸ“ Nombre", placeholder="Mi CampaÃ±a 2025")
            daily_budget = st.number_input("ğŸ’° Presupuesto (COP)", 10000, 1000000, 50000, 5000)
        with col2:
            campaign_objective = st.selectbox("ğŸ¯ Objetivo", ["Leads", "Ventas", "TrÃ¡fico"])
            bidding_strategy = st.selectbox("ğŸ’¡ Estrategia", ["Maximizar Clics", "CPC Manual"])
    
    st.markdown("---")
    
    # PASO 3: DescripciÃ³n del negocio
    st.markdown("""
    <div class="neural-card">
        <h3>ğŸ¢ PASO 3: NEGOCIO Y GRUPOS</h3>
    </div>
    """, unsafe_allow_html=True)
    
    business_description = st.text_area(
        "ğŸ“Š DescripciÃ³n del Negocio",
        placeholder="Describe tu negocio...",
        height=100,
        help="DescripciÃ³n general que aplica a todos los grupos"
    )
    
    business_url = st.text_input(
        "ğŸŒ URL Principal del Sitio",
        placeholder="https://ejemplo.com",
        help="URL base de tu negocio"
    )
    
    # NUEVA FUNCIONALIDAD: NÃºmero de grupos
    num_ad_groups = st.slider(
        "ğŸ“¦ NÃºmero de Grupos de Anuncios",
        min_value=1,
        max_value=10,
        value=1,
        help="Â¿CuÃ¡ntos grupos de anuncios diferentes quieres crear?"
    )
    
    st.markdown("---")
    
    # âœ… NUEVA SECCIÃ“N: ConfiguraciÃ³n por grupo (si num_ad_groups > 1)
    ad_groups_config = []
    
    if num_ad_groups > 1:
        st.markdown("""
        <div class="neural-card">
            <h3>ğŸ“‹ CONFIGURACIÃ“N POR GRUPO</h3>
            <p>Configura keywords y URL especÃ­ficas para cada grupo</p>
        </div>
        """, unsafe_allow_html=True)
        
        for i in range(num_ad_groups):
            with st.expander(f"ğŸ“¦ Grupo #{i+1}", expanded=(i==0)):
                st.markdown(f"<div class='group-box'>", unsafe_allow_html=True)
                
                group_name = st.text_input(
                    f"ğŸ“› Nombre del Grupo #{i+1}",
                    value=f"Grupo {i+1}",
                    key=f"group_name_{i}",
                    placeholder="Ej: Amarres de Amor"
                )
                
                group_keywords = st.text_area(
                    f"ğŸ”‘ Keywords para Grupo #{i+1}",
                    placeholder="amarre de amor\nhechizo amor\nbrujerÃ­a amor\n(una por lÃ­nea)",
                    height=120,
                    key=f"group_keywords_{i}",
                    help="Keywords especÃ­ficas para este grupo (una por lÃ­nea)"
                )
                
                group_url = st.text_input(
                    f"ğŸŒ URL especÃ­fica para Grupo #{i+1}",
                    placeholder="https://ejemplo.com/amarres",
                    key=f"group_url_{i}",
                    help="URL de destino para este grupo especÃ­fico"
                )
                
                # Procesar keywords
                keywords_list = [kw.strip() for kw in group_keywords.split('\n') if kw.strip()]
                
                # Validar
                if keywords_list and group_url:
                    st.success(f"âœ… Grupo #{i+1}: {len(keywords_list)} keywords configuradas")
                    ad_groups_config.append({
                        'name': group_name,
                        'keywords': keywords_list,
                        'url': group_url
                    })
                elif keywords_list or group_url:
                    st.warning(f"âš ï¸ Completa keywords Y URL para el Grupo #{i+1}")
                
                st.markdown("</div>", unsafe_allow_html=True)
    
    else:
        # Si solo es 1 grupo, usar el formato anterior
        st.markdown("**ğŸ”‘ Keywords Principales:**")
        target_keywords = st.text_area(
            "Keywords:",
            placeholder="keyword1, keyword2, keyword3",
            height=100,
            help="Palabras clave separadas por comas o lÃ­neas"
        )
        
        # Procesar keywords
        if isinstance(target_keywords, str):
            keywords_list = []
            for keyword in target_keywords.replace('\n', ',').split(','):
                keyword = keyword.strip()
                if keyword:
                    keywords_list.append(keyword)
        else:
            keywords_list = target_keywords if target_keywords else []
        
        if keywords_list:
            ad_groups_config.append({
                'name': 'Grupo Principal',
                'keywords': keywords_list,
                'url': business_url
            })
    
    st.markdown("---")
    
    # PASO 4: ConfiguraciÃ³n avanzada (aplica a TODOS los grupos)
    with st.expander("âš™ï¸ CONFIGURACIÃ“N AVANZADA (aplica a todos los grupos)"):
        col1, col2 = st.columns(2)
        
        with col1:
            ai_creativity = st.slider("ğŸ¨ Creatividad IA", 0.1, 1.0, 0.7, 0.1)
            keywords_per_group = st.slider("ğŸ”‘ Keywords/Grupo", 5, 30, 15)
            use_magnetic = st.checkbox("ğŸ”´ Modo MAGNÃ‰TICO", False)
        
        with col2:
            ads_per_group = st.slider("ğŸ“ Anuncios/Grupo", 3, 15, 8)
            match_types = st.multiselect("ğŸ¯ Concordancia", ["Exacta", "Frase", "Amplia"], ["Exacta", "Frase"])
    
    st.markdown("---")
    
    # PASO 5: ValidaciÃ³n y publicaciÃ³n
    st.markdown("""
    <div class="neural-card">
        <h3>ğŸš€ PASO 4: PUBLICAR</h3>
    </div>
    """, unsafe_allow_html=True)
    
    # Validaciones
    can_publish = True
    
    if not business_description:
        st.error("âŒ DescripciÃ³n del negocio requerida")
        can_publish = False
    
    if campaign_mode == "ğŸ†• Crear Nueva CampaÃ±a" and not campaign_name:
        st.error("âŒ Nombre de campaÃ±a requerido")
        can_publish = False
    
    if not ad_groups_config:
        st.error(f"âŒ Debes configurar al menos 1 grupo con keywords y URL")
        can_publish = False
    
    if len(ad_groups_config) < num_ad_groups:
        st.warning(f"âš ï¸ Configurados {len(ad_groups_config)}/{num_ad_groups} grupos")
        can_publish = False
    
    # Mostrar resumen
    if ad_groups_config:
        with st.expander("ğŸ“Š Resumen de ConfiguraciÃ³n"):
            st.write(f"**Total de grupos:** {len(ad_groups_config)}")
            for idx, group in enumerate(ad_groups_config, 1):
                st.write(f"**Grupo {idx}: {group['name']}**")
                st.write(f"  - Keywords: {len(group['keywords'])}")
                st.write(f"  - URL: {group['url']}")
    
    # BotÃ³n de publicaciÃ³n
    if st.button("ğŸš€ INICIAR AUTOPUBLICADOR", type="primary", use_container_width=True, disabled=not can_publish):
        
        with st.spinner("ğŸ”„ Generando y publicando..."):
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            try:
                # Paso 1: Generar anuncios para cada grupo
                status_text.markdown('<div class="matrix-text" style="font-family: Courier New; color: #00ff00; background: #000; padding: 1rem; border-radius: 8px;">ğŸ” Generando anuncios para cada grupo...</div>', unsafe_allow_html=True)
                progress_bar.progress(0.2)
                
                # Configurar generaciÃ³n
                generation_config = {
                    'business_description': business_description,
                    'num_ad_groups': len(ad_groups_config),
                    'keywords_per_group': keywords_per_group,
                    'ads_per_group': ads_per_group,
                    'ai_creativity': ai_creativity,
                    'match_types': match_types,
                    'use_magnetic': use_magnetic,
                    'ad_groups_config': ad_groups_config  # âœ… Pasar configuraciÃ³n especÃ­fica
                }
                
                # Generar grupos con IA
                try:
                    generated_ad_groups = intelligent_autopilot.generate_ad_groups_from_config(
                        business_description,
                        ad_groups_config,
                        generation_config
                    )
                    
                    if not generated_ad_groups:
                        st.error("âŒ No se generaron grupos")
                        return
                    
                    st.info(f"âœ… {len(generated_ad_groups)} grupos generados con IA")
                    
                except Exception as e:
                    st.error(f"âŒ Error generando: {str(e)}")
                    return
                
                progress_bar.progress(0.5)
                
                # Paso 2: Publicar a Google Ads
                if campaign_mode == "ğŸ“‹ Usar CampaÃ±a Existente":
                    status_text.markdown('<div class="matrix-text" style="font-family: Courier New; color: #00ff00; background: #000; padding: 1rem; border-radius: 8px;">ğŸ“‹ Publicando en campaÃ±a existente...</div>', unsafe_allow_html=True)
                    
                    result = intelligent_autopilot.publish_complete_campaign(
                        customer_id=selected_customer,
                        campaign_option=selected_campaign_obj,
                        ad_groups=generated_ad_groups
                    )
                
                else:  # Nueva campaÃ±a
                    status_text.markdown('<div class="matrix-text" style="font-family: Courier New; color: #00ff00; background: #000; padding: 1rem; border-radius: 8px;">ğŸ†• Creando nueva campaÃ±a...</div>', unsafe_allow_html=True)
                    
                    campaign_config = {
                        'name': campaign_name,
                        'daily_budget': daily_budget,
                        'objective': campaign_objective,
                        'bidding_strategy': bidding_strategy,
                        'business_url': business_url
                    }
                    
                    new_campaign_option = CampaignOption(
                        campaign_id="new",
                        campaign_name=campaign_name,
                        campaign_status="PAUSED",
                        campaign_type="SEARCH",
                        is_new=True
                    )
                    
                    result = intelligent_autopilot.publish_complete_campaign(
                        customer_id=selected_customer,
                        campaign_option=new_campaign_option,
                        ad_groups=generated_ad_groups,
                        campaign_config=campaign_config
                    )
                
                progress_bar.progress(1.0)
                status_text.empty()
                
                # Mostrar resultados
                if result.get('success'):
                    st.balloons()
                    st.success("ğŸ‰ Â¡AUTOPUBLICADOR EXITOSO!")
                    
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("ğŸ“¦ Grupos", len(result.get('ad_group_ids', [])))
                    with col2:
                        st.metric("ğŸ“ Anuncios", len(result.get('ad_ids', [])))
                    with col3:
                        st.metric("ğŸ”‘ Keywords", len(result.get('keyword_ids', [])))
                    
                    if result.get('campaign_id'):
                        st.info(f"ğŸ†” CampaÃ±a ID: {result['campaign_id']}")
                else:
                    st.error("âŒ Error en publicaciÃ³n")
                    if result.get('errors'):
                        for err in result['errors']:
                            st.error(f"â€¢ {err}")
            
            except Exception as e:
                st.error(f"âŒ Error: {e}")
                logger.error(f"Error autopilot: {e}", exc_info=True)
ğŸ”¥ Cambios Clave:
âœ… Slider "ğŸ“¦ NÃºmero de Grupos" - El usuario selecciona cuÃ¡ntos grupos quiere (1-10)

âœ… Si num_ad_groups > 1: Se abre un expander por cada grupo donde el usuario ingresa:

Nombre del grupo
Keywords especÃ­ficas (una por lÃ­nea)
URL especÃ­fica
âœ… Si num_ad_groups == 1: Usa el formato anterior (keywords generales + URL base)

âœ… ConfiguraciÃ³n Avanzada: Sigue aplicando a TODOS los grupos (creatividad, keywords/grupo, anuncios/grupo, modo magnÃ©tico, etc.)

âœ… ValidaciÃ³n: Verifica que todos los grupos tengan keywords Y URL antes de publicar

âœ… PublicaciÃ³n: Usa generate_ad_groups_from_config() (nuevo mÃ©todo) que recibe la configuraciÃ³n especÃ­fica de cada grupo y genera anuncios con IA respetando esas keywords y URLs

âœ… Resultado: Publica directamente a Google Ads vÃ­a API usando publish_complete_campaign()

ğŸ“ Necesitas agregar este mÃ©todo en services/intelligent_autopilot.py:
Python
def generate_ad_groups_from_config(
    self,
    business_description: str,
    ad_groups_config: List[Dict],
    generation_config: Dict
) -> List[Dict]:
    """
    Genera grupos de anuncios basÃ¡ndose en configuraciÃ³n especÃ­fica por grupo
    
    Args:
        business_description: DescripciÃ³n general del negocio
        ad_groups_config: Lista con configuraciÃ³n de cada grupo:
            [{'name': 'Grupo 1', 'keywords': ['kw1', 'kw2'], 'url': 'https://...'}]
        generation_config: ConfiguraciÃ³n global (creatividad, anuncios/grupo, etc.)
    
    Returns:
        Lista de grupos de anuncios generados con IA
    """
    generated_groups = []
    
    for group_config in ad_groups_config:
        try:
            # Usar AI para generar anuncios especÃ­ficos para este grupo
            ads = self.ai_generator.generate_batch(
                keywords=group_config['keywords'],
                num_ads=generation_config['ads_per_group'],
                num_headlines=15,
                num_descriptions=4,
                tone=generation_config.get('tone', 'profesional'),
                validate=True,
                business_type='generic',
                save_to_csv=False
            )
            
            generated_groups.append({
                'name': group_config['name'],
                'keywords': group_config['keywords'],
                'final_url': group_config['url'],
                'ads': ads['ads'],
                'max_cpc_bid': 1.0  # Puedes calcularlo dinÃ¡micamente
            })
        
        except Exception as e:
            logger.error(f"Error generando grupo {group_config['name']}: {e}")
            continue
    
    return generated_groups



ğŸ”§ CorrecciÃ³n del mÃ©todo generate_ad_groups_from_config en intelligent_autopilot.py:
Reemplaza el mÃ©todo existente con este:

Python
def generate_ad_groups_from_config(
    self,
    business_description: str,
    ad_groups_config: List[Dict],
    generation_config: Dict
) -> List[Dict[str, Any]]:
    """
    Genera grupos de anuncios basÃ¡ndose en configuraciÃ³n especÃ­fica por grupo
    
    Args:
        business_description: DescripciÃ³n general del negocio
        ad_groups_config: Lista con configuraciÃ³n de cada grupo:
            [{'name': 'Grupo 1', 'keywords': ['kw1', 'kw2'], 'url': 'https://...'}]
        generation_config: ConfiguraciÃ³n global (creatividad, anuncios/grupo, etc.)
    
    Returns:
        Lista de grupos de anuncios generados con IA
    """
    logger.info("="*70)
    logger.info("ğŸš€ GENERANDO GRUPOS DESDE CONFIGURACIÃ“N ESPECÃFICA")
    logger.info(f"ğŸ“¦ Total de grupos configurados: {len(ad_groups_config)}")
    logger.info("="*70)
    
    generated_groups = []
    
    for i, group_config in enumerate(ad_groups_config):
        try:
            group_name = group_config.get('name', f'Grupo {i+1}')
            keywords = group_config.get('keywords', [])
            final_url = group_config.get('url', 'https://www.ejemplo.com')
            
            logger.info(f"ğŸ“‹ Procesando grupo: {group_name}")
            logger.info(f"ğŸ”‘ Keywords: {', '.join(keywords[:5])}{'...' if len(keywords) > 5 else ''}")
            logger.info(f"ğŸŒ URL: {final_url}")
            
            if not keywords:
                logger.warning(f"âš ï¸ Grupo {group_name} no tiene keywords, saltando...")
                continue
            
            # Configurar el generador de IA
            ai_provider = generation_config.get('ai_provider', 'openai')
            ai_model = generation_config.get('ai_model', 'gpt-4o')
            creativity = generation_config.get('ai_creativity', 0.7)
            use_magnetic = generation_config.get('use_magnetic', False)
            ads_per_group = generation_config.get('ads_per_group', 8)
            
            logger.info(f"ğŸ¤– ConfiguraciÃ³n IA: {ai_provider}/{ai_model}")
            logger.info(f"ğŸ¨ Creatividad: {creativity}, MagnÃ©tico: {use_magnetic}")
            
            # Generar anuncios especÃ­ficos para este grupo usando IA
            ads_result = self._generate_real_ads_with_ai(
                keywords=keywords,
                business_description=business_description,
                business_url=final_url,
                num_ads=ads_per_group,
                ai_provider=ai_provider,
                ai_model=ai_model,
                tone='profesional',  # Puedes hacer esto configurable
                creativity=creativity,
                use_magnetic=use_magnetic
            )
            
            if not ads_result:
                logger.warning(f"âš ï¸ No se generaron anuncios para el grupo {group_name}")
                continue
            
            logger.info(f"âœ… {len(ads_result)} anuncios generados para {group_name}")
            
            # Aplicar tipos de concordancia a las keywords
            match_types = generation_config.get('match_types', ['Exacta', 'Frase'])
            keywords_with_match = self._apply_match_types(keywords, match_types)
            
            # Calcular CPC inteligente
            max_cpc_bid = self._calculate_smart_bid(keywords)
            
            # Crear el grupo de anuncios
            ad_group = {
                'name': group_name,
                'theme': self._extract_theme(keywords),
                'keywords': keywords,  # âœ… Keywords completas
                'negative_keywords': self._generate_negative_keywords(business_description),
                'ads': ads_result,
                'max_cpc_bid': max_cpc_bid,
                'final_url': final_url,
                'match_type': match_types[0] if match_types else 'BROAD',
                'all_match_types': keywords_with_match,
                'targeting': {
                    'country': 'US',
                    'currency': 'COP',
                    'age_range': None,
                    'gender': None
                },
                'status': 'ready',
                'score': 85.0 + (i * 2)  # Score base con variaciÃ³n
            }
            
            generated_groups.append(ad_group)
            logger.info(f"âœ… Grupo {group_name} completado exitosamente")
            
        except Exception as e:
            logger.error(f"âŒ Error generando grupo {group_config.get('name', f'Grupo {i+1}')}: {e}")
            logger.error(f"Traceback: {e}", exc_info=True)
            continue
    
    logger.info("="*70)
    logger.info(f"ğŸ GENERACIÃ“N COMPLETADA: {len(generated_groups)}/{len(ad_groups_config)} grupos exitosos")
    logger.info("="*70)
    
    return generated_groups
ğŸ“ Cambios clave realizados:
âœ… ValidaciÃ³n de keywords: Verifica que cada grupo tenga keywords antes de procesarlo
âœ… ExtracciÃ³n correcta de configuraciÃ³n: Lee ai_provider, ai_model, creativity, use_magnetic, etc. del generation_config
âœ… Llamada correcta a _generate_real_ads_with_ai: Pasa todos los parÃ¡metros necesarios incluyendo use_magnetic
âœ… Manejo de errores robusto: Si un grupo falla, continÃºa con los siguientes
âœ… Logging detallado: Para debugging y seguimiento
âœ… Estructura completa de grupo: Incluye todos los campos necesarios (keywords, ads, match_types, targeting, etc.)
âœ… Soporte para URLs especÃ­ficas: Cada grupo puede tener su propia URL de destino


ğŸ”§ SoluciÃ³n: Agregar el mÃ©todo correcto a IntelligentAutopilot
Abre services/intelligent_autopilot.py y agrega este mÃ©todo dentro de la clase IntelligentAutopilot (despuÃ©s del mÃ©todo get_campaign_details y antes de generate_ad_groups_for_business):

Python
# ========================================================================
# GENERACIÃ“N MULTI-GRUPO CON CONFIGURACIÃ“N ESPECÃFICA
# ========================================================================

def generate_ad_groups_from_config(
    self,
    business_description: str,
    ad_groups_config: List[Dict],
    generation_config: Dict
) -> List[Dict[str, Any]]:
    """
    Genera grupos de anuncios basÃ¡ndose en configuraciÃ³n especÃ­fica por grupo
    
    Args:
        business_description: DescripciÃ³n general del negocio
        ad_groups_config: Lista con configuraciÃ³n de cada grupo:
            [{'name': 'Grupo 1', 'keywords': ['kw1', 'kw2'], 'url': 'https://...'}]
        generation_config: ConfiguraciÃ³n global con:
            - ai_provider: str (openai/gemini/anthropic)
            - ai_model: str (gpt-4o/gemini-pro/etc)
            - ai_creativity: float (0.1-1.0)
            - ads_per_group: int
            - match_types: List[str]
            - use_magnetic: bool
    
    Returns:
        Lista de grupos de anuncios generados con IA
    """
    logger.info("="*70)
    logger.info("ğŸš€ GENERANDO GRUPOS DESDE CONFIGURACIÃ“N ESPECÃFICA")
    logger.info(f"ğŸ“¦ Total de grupos configurados: {len(ad_groups_config)}")
    logger.info(f"âš™ï¸ Config global: {generation_config}")
    logger.info("="*70)
    
    generated_groups = []
    
    for i, group_config in enumerate(ad_groups_config):
        try:
            # âœ… Extraer datos del grupo
            group_name = group_config.get('name', f'Grupo {i+1}')
            keywords = group_config.get('keywords', [])
            final_url = group_config.get('url', 'https://www.ejemplo.com')
            
            logger.info(f"\n{'='*70}")
            logger.info(f"ğŸ“‹ PROCESANDO GRUPO {i+1}/{len(ad_groups_config)}: {group_name}")
            logger.info(f"{'='*70}")
            logger.info(f"ğŸ”‘ Keywords ({len(keywords)}): {', '.join(keywords[:5])}{'...' if len(keywords) > 5 else ''}")
            logger.info(f"ğŸŒ URL: {final_url}")
            
            # âœ… Validar keywords
            if not keywords:
                logger.warning(f"âš ï¸ Grupo {group_name} sin keywords, saltando...")
                continue
            
            # âœ… Extraer configuraciÃ³n de generaciÃ³n
            ai_provider = generation_config.get('ai_provider', 'openai')
            ai_model = generation_config.get('ai_model', 'gpt-4o')
            creativity = generation_config.get('ai_creativity', 0.7)
            use_magnetic = generation_config.get('use_magnetic', False)
            ads_per_group = generation_config.get('ads_per_group', 8)
            match_types = generation_config.get('match_types', ['Exacta', 'Frase'])
            
            logger.info(f"ğŸ¤– IA: {ai_provider}/{ai_model}")
            logger.info(f"ğŸ¨ Creatividad: {creativity}")
            logger.info(f"ğŸ”´ Modo MagnÃ©tico: {'SÃ' if use_magnetic else 'NO'}")
            logger.info(f"ğŸ“ Anuncios a generar: {ads_per_group}")
            
            # âœ… GENERAR ANUNCIOS CON IA
            logger.info("ğŸ¨ Generando anuncios con IA...")
            
            ads_result = self._generate_real_ads_with_ai(
                keywords=keywords,
                business_description=business_description,
                business_url=final_url,
                num_ads=ads_per_group,
                ai_provider=ai_provider,
                ai_model=ai_model,
                tone='profesional',
                creativity=creativity,
                use_magnetic=use_magnetic
            )
            
            if not ads_result or len(ads_result) == 0:
                logger.warning(f"âš ï¸ No se generaron anuncios para {group_name}")
                continue
            
            logger.info(f"âœ… {len(ads_result)} anuncios generados exitosamente")
            
            # âœ… Aplicar match types a keywords
            logger.info(f"ğŸ¯ Aplicando match types: {match_types}")
            keywords_with_match = self._apply_match_types(keywords, match_types)
            
            # âœ… Calcular CPC inteligente
            max_cpc_bid = self._calculate_smart_bid(keywords)
            logger.info(f"ğŸ’° CPC sugerido: ${max_cpc_bid:.2f}")
            
            # âœ… CREAR ESTRUCTURA COMPLETA DEL GRUPO
            ad_group = {
                'name': group_name,
                'theme': self._extract_theme(keywords),
                'keywords': keywords,  # Keywords originales
                'negative_keywords': self._generate_negative_keywords(business_description),
                'ads': ads_result,  # Anuncios generados con IA
                'max_cpc_bid': max_cpc_bid,
                'final_url': final_url,
                'match_type': match_types[0] if match_types else 'BROAD',
                'all_match_types': keywords_with_match,  # Keywords con match types
                'targeting': {
                    'country': 'US',
                    'currency': 'COP',
                    'age_range': None,
                    'gender': None
                },
                'status': 'ready',
                'score': 85.0 + (i * 2)
            }
            
            generated_groups.append(ad_group)
            
            logger.info(f"âœ… Grupo '{group_name}' completado exitosamente")
            logger.info(f"   - Keywords: {len(keywords)}")
            logger.info(f"   - Anuncios: {len(ads_result)}")
            logger.info(f"   - CPC: ${max_cpc_bid:.2f}")
            logger.info(f"   - URL: {final_url}")
            
        except Exception as e:
            logger.error(f"âŒ Error generando grupo {i+1}: {e}")
            logger.error(f"Traceback:", exc_info=True)
            continue
    
    logger.info("\n" + "="*70)
    logger.info(f"ğŸ GENERACIÃ“N COMPLETADA")
    logger.info(f"âœ… Exitosos: {len(generated_groups)}/{len(ad_groups_config)}")
    logger.info(f"âŒ Fallidos: {len(ad_groups_config) - len(generated_groups)}")
    logger.info("="*70 + "\n")
    
    return generated_groups
ğŸ“ UbicaciÃ³n exacta en intelligent_autopilot.py:
Busca esta lÃ­nea en tu archivo:

Python
def generate_ad_groups_for_business(
    self,
    business_description: str,
    target_keywords,  # Puede ser str o List[str]
    generation_config: Dict[str, Any]
) -> List[Dict[str, Any]]:
Y JUSTO ANTES de ese mÃ©todo, agrega el mÃ©todo generate_ad_groups_from_config que te acabo de dar.

ğŸ—‘ï¸ TAMBIÃ‰N: Elimina el cÃ³digo duplicado/roto
En tu intelligent_autopilot.py hay un bloque de cÃ³digo duplicado y roto que empieza asÃ­:

Python
def generate_ad_groups_from_config(
    self,
    business_description: str,
    ad_groups_config: list[AdGroupConfig],
    generation_config: dict,
) -> dict:
    """
    Generates ad groups based on per-group configuration and AI-generated ads.
    """
    generated_ad_groups_data = []
    
    # ... cÃ³digo ...
    
    return {"ad_groups": generated_ad_groups_data}
    logger.info("="*70)  # âš ï¸ CÃ“DIGO MUERTO (nunca se ejecuta)
    # ... mÃ¡s cÃ³digo que nunca se ejecuta ...
âŒ ELIMINA TODO ESE BLOQUE (desde la lÃ­nea del primer def generate_ad_groups_from_config hasta donde termina ese cÃ³digo duplicado).

âœ… Estructura final correcta de intelligent_autopilot.py:
Python
class IntelligentAutopilot:
    def __init__(self, google_ads_client):
        # ... cÃ³digo existente ...
    
    def get_available_campaigns(self, customer_id: str) -> List:
        # ... cÃ³digo existente ...
    
    def get_campaign_details(self, customer_id: str, campaign_id: str) -> Dict[str, Any]:
        # ... cÃ³digo existente ...
    
    # âœ… AGREGAR AQUÃ EL MÃ‰TODO NUEVO
    def generate_ad_groups_from_config(
        self,
        business_description: str,
        ad_groups_config: List[Dict],
        generation_config: Dict
    ) -> List[Dict[str, Any]]:
        # ... cÃ³digo que te di arriba ...
    
    # âœ… ESTE MÃ‰TODO YA EXISTE (dÃ©jalo como estÃ¡)
    def generate_ad_groups_for_business(
        self,
        business_description: str,
        target_keywords,
        generation_config: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        # ... cÃ³digo existente ...
    
    # ... resto de mÃ©todos ...
ğŸ§ª Prueba:
DespuÃ©s de agregar el mÃ©todo:

Reinicia Streamlit
Ve a AUTOPILOT 2050
Configura mÃºltiples grupos
Presiona ğŸš€ INICIAR AUTOPUBLICADOR
DeberÃ­a funcionar correctamente. ğŸš€

intelligent_autopilot2.py
autopilot_publisher.py
pasted5.txt
You said: aun sale: âŒ Error generando grupos de anuncios:
aun sale:

âŒ Error generando grupos de anuncios: 'IntelligentAutopilot' object has no attribute 'generate_ad_groups_from_config'



@intelligent_autopilot2.py @autopilot_publisher.py @pasted5.txt 4_ai_ad_generator.py
Copilot said: El problema es que el mÃ©todo `generate_ad_groups_from_config`
El problema es que el mÃ©todo generate_ad_groups_from_config NO estÃ¡ dentro de la clase IntelligentAutopilot en tu archivo intelligent_autopilot2.py.

Mira la lÃ­nea 201 de tu archivo:

Python
    # ========================================================================
# GENERACIÃ“N MULTI-GRUPO CON CONFIGURACIÃ“N ESPECÃFICA
# ========================================================================

def generate_ad_groups_from_config(  # âŒ ESTO ESTÃ MAL INDENTADO
    self,
    business_description: str,
    ...
La indentaciÃ³n estÃ¡ mal - el mÃ©todo estÃ¡ definido fuera de la clase, por eso Python no lo encuentra.

âœ… SoluciÃ³n: Corregir la indentaciÃ³n
Abre intelligent_autopilot2.py y busca la lÃ­nea ~201 donde dice:

Python
    # ========================================================================
# GENERACIÃ“N MULTI-GRUPO CON CONFIGURACIÃ“N ESPECÃFICA
# ========================================================================

def generate_ad_groups_from_config(
Debe quedar asÃ­ (con 4 espacios de indentaciÃ³n):

Python
    # ========================================================================
    # GENERACIÃ“N MULTI-GRUPO CON CONFIGURACIÃ“N ESPECÃFICA
    # ========================================================================
    
    def generate_ad_groups_from_config(
        self,
        business_description: str,
        ad_groups_config: List[Dict],
        generation_config: Dict
    ) -> List[Dict[str, Any]]:
ğŸ”§ Archivo corregido completo (lÃ­neas 201-350):
Reemplaza desde la lÃ­nea 201 hasta donde termina ese mÃ©todo con esto:

Python
    # ========================================================================
    # GENERACIÃ“N MULTI-GRUPO CON CONFIGURACIÃ“N ESPECÃFICA
    # ========================================================================
    
    def generate_ad_groups_from_config(
        self,
        business_description: str,
        ad_groups_config: List[Dict],
        generation_config: Dict
    ) -> List[Dict[str, Any]]:
        """
        Genera grupos de anuncios basÃ¡ndose en configuraciÃ³n especÃ­fica por grupo
        
        Args:
            business_description: DescripciÃ³n general del negocio
            ad_groups_config: Lista con configuraciÃ³n de cada grupo:
                [{'name': 'Grupo 1', 'keywords': ['kw1', 'kw2'], 'url': 'https://...'}]
            generation_config: ConfiguraciÃ³n global con:
                - ai_provider: str (openai/gemini/anthropic)
                - ai_model: str (gpt-4o/gemini-pro/etc)
                - ai_creativity: float (0.1-1.0)
                - ads_per_group: int
                - match_types: List[str]
                - use_magnetic: bool
        
        Returns:
            Lista de grupos de anuncios generados con IA
        """
        logger.info("="*70)
        logger.info("ğŸš€ GENERANDO GRUPOS DESDE CONFIGURACIÃ“N ESPECÃFICA")
        logger.info(f"ğŸ“¦ Total de grupos configurados: {len(ad_groups_config)}")
        logger.info(f"âš™ï¸ Config global: {generation_config}")
        logger.info("="*70)
        
        generated_groups = []
        
        for i, group_config in enumerate(ad_groups_config):
            try:
                # âœ… Extraer datos del grupo
                group_name = group_config.get('name', f'Grupo {i+1}')
                keywords = group_config.get('keywords', [])
                final_url = group_config.get('url', 'https://www.ejemplo.com')
                
                logger.info(f"\n{'='*70}")
                logger.info(f"ğŸ“‹ PROCESANDO GRUPO {i+1}/{len(ad_groups_config)}: {group_name}")
                logger.info(f"{'='*70}")
                logger.info(f"ğŸ”‘ Keywords ({len(keywords)}): {', '.join(keywords[:5])}{'...' if len(keywords) > 5 else ''}")
                logger.info(f"ğŸŒ URL: {final_url}")
                
                # âœ… Validar keywords
                if not keywords:
                    logger.warning(f"âš ï¸ Grupo {group_name} sin keywords, saltando...")
                    continue
                
                # âœ… Extraer configuraciÃ³n de generaciÃ³n
                ai_provider = generation_config.get('ai_provider', 'openai')
                ai_model = generation_config.get('ai_model', 'gpt-4o')
                creativity = generation_config.get('ai_creativity', 0.7)
                use_magnetic = generation_config.get('use_magnetic', False)
                ads_per_group = generation_config.get('ads_per_group', 8)
                match_types = generation_config.get('match_types', ['Exacta', 'Frase'])
                
                logger.info(f"ğŸ¤– IA: {ai_provider}/{ai_model}")
                logger.info(f"ğŸ¨ Creatividad: {creativity}")
                logger.info(f"ğŸ”´ Modo MagnÃ©tico: {'SÃ' if use_magnetic else 'NO'}")
                logger.info(f"ğŸ“ Anuncios a generar: {ads_per_group}")
                
                # âœ… GENERAR ANUNCIOS CON IA
                logger.info("ğŸ¨ Generando anuncios con IA...")
                
                ads_result = self._generate_real_ads_with_ai(
                    keywords=keywords,
                    business_description=business_description,
                    business_url=final_url,
                    num_ads=ads_per_group,
                    ai_provider=ai_provider,
                    ai_model=ai_model,
                    tone='profesional',
                    creativity=creativity,
                    use_magnetic=use_magnetic
                )
                
                if not ads_result or len(ads_result) == 0:
                    logger.warning(f"âš ï¸ No se generaron anuncios para {group_name}")
                    continue
                
                logger.info(f"âœ… {len(ads_result)} anuncios generados exitosamente")
                
                # âœ… Aplicar match types a keywords
                logger.info(f"ğŸ¯ Aplicando match types: {match_types}")
                keywords_with_match = self._apply_match_types(keywords, match_types)
                
                # âœ… Calcular CPC inteligente
                max_cpc_bid = self._calculate_smart_bid(keywords)
                logger.info(f"ğŸ’° CPC sugerido: ${max_cpc_bid:.2f}")
                
                # âœ… CREAR ESTRUCTURA COMPLETA DEL GRUPO
                ad_group = {
                    'name': group_name,
                    'theme': self._extract_theme(keywords),
                    'keywords': keywords,  # Keywords originales
                    'negative_keywords': self._generate_negative_keywords(business_description),
                    'ads': ads_result,  # Anuncios generados con IA
                    'max_cpc_bid': max_cpc_bid,
                    'final_url': final_url,
                    'match_type': match_types[0] if match_types else 'BROAD',
                    'all_match_types': keywords_with_match,  # Keywords con match types
                    'targeting': {
                        'country': 'US',
                        'currency': 'COP',
                        'age_range': None,
                        'gender': None
                    },
                    'status': 'ready',
                    'score': 85.0 + (i * 2)
                }
                
                generated_groups.append(ad_group)
                
                logger.info(f"âœ… Grupo '{group_name}' completado exitosamente")
                logger.info(f"   - Keywords: {len(keywords)}")
                logger.info(f"   - Anuncios: {len(ads_result)}")
                logger.info(f"   - CPC: ${max_cpc_bid:.2f}")
                logger.info(f"   - URL: {final_url}")
                
            except Exception as e:
                logger.error(f"âŒ Error generando grupo {i+1}: {e}")
                logger.error(f"Traceback:", exc_info=True)
                continue
        
        logger.info("\n" + "="*70)
        logger.info(f"ğŸ GENERACIÃ“N COMPLETADA")
        logger.info(f"âœ… Exitosos: {len(generated_groups)}/{len(ad_groups_config)}")
        logger.info(f"âŒ Fallidos: {len(ad_groups_config) - len(generated_groups)}")
        logger.info("="*70 + "\n")
        
        return generated_groups
ğŸ“ VerificaciÃ³n rÃ¡pida de indentaciÃ³n:
La estructura debe quedar:

Python
class IntelligentAutopilot:
    """ğŸš€ AUTOPUBLICADOR INTELIGENTE CON IA"""
    
    def __init__(self, google_ads_client):
        # ...
    
    def get_available_campaigns(self, customer_id: str) -> List:
        # ...
    
    def get_campaign_details(self, customer_id: str, campaign_id: str) -> Dict[str, Any]:
        # ...
    
    # âœ… ESTE MÃ‰TODO DEBE ESTAR AQUÃ (DENTRO DE LA CLASE)
    def generate_ad_groups_from_config(
        self,
        business_description: str,
        ad_groups_config: List[Dict],
        generation_config: Dict
    ) -> List[Dict[str, Any]]:
        # ... cÃ³digo del mÃ©todo ...
    
    def generate_ad_groups_for_business(
        self,
        business_description: str,
        target_keywords,
        generation_config: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        # ...
    
    # ... resto de mÃ©todos ...
ğŸ§ª Prueba:
Guarda el archivo corregido
Reinicia Streamlit
Ve a AUTOPILOT 2050
Configura tus grupos
Presiona ğŸš€ INICIAR AUTOPUBLICADOR
Ahora deberÃ­a funcionar correctamente. ğŸš€

El problema era simplemente indentaciÃ³n incorrecta - el mÃ©todo estaba definido fuera de la clase por un error de formato.