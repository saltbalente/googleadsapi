Copilot said: # ‚è∏Ô∏è **Funcionalidad: Pausar Anuncios v√≠a API** Vamos
‚è∏Ô∏è Funcionalidad: Pausar Anuncios v√≠a API
Vamos a agregar la capacidad de pausar anuncios directamente desde el dashboard, similar a c√≥mo hicimos con los ajustes de pujas en keywords.

üèóÔ∏è Arquitectura de la Soluci√≥n
Code
1. Usuario selecciona anuncios vampiro/cr√≠ticos
2. Click en bot√≥n "Pausar Seleccionados"
3. Confirmaci√≥n (evitar pausas accidentales)
4. API de Google Ads pausa los anuncios
5. Feedback visual de √©xito/errores
üîß Paso 1: Crear services/ad_management_service.py
Python
"""
Ad Management Service - Gestiona acciones sobre anuncios (pausar, activar, etc.)
Compatible con Google Ads API v21
"""

from google.ads.googleads.client import GoogleAdsClient
from google.ads.googleads.errors import GoogleAdsException
from google.protobuf import field_mask_pb2
from typing import List, Dict, Tuple
import logging
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class AdAction:
    """Representa una acci√≥n sobre un anuncio"""
    customer_id: str
    ad_group_id: str
    ad_id: str
    ad_headlines: str
    campaign_name: str
    ad_group_name: str
    current_status: str
    reason: str

class AdManagementService:
    """Servicio para gestionar acciones sobre anuncios"""
    
    def __init__(self, google_ads_client):
        """
        Inicializa el servicio
        
        Args:
            google_ads_client: GoogleAdsClient o GoogleAdsClientWrapper
        """
        # Detectar si es wrapper y extraer cliente real
        if hasattr(google_ads_client, 'client'):
            self.client = google_ads_client.client
            logger.info("Usando cliente real extra√≠do de GoogleAdsClientWrapper")
        else:
            self.client = google_ads_client
            logger.info("Usando GoogleAdsClient directo")
        
        # Inicializar servicios
        try:
            self.ad_group_ad_service = self.client.get_service("AdGroupAdService")
            self.googleads_service = self.client.get_service("GoogleAdsService")
            logger.info("‚úÖ AdManagementService inicializado correctamente")
        except Exception as e:
            logger.error(f"‚ùå Error inicializando servicios: {e}")
            raise
    
    def pause_ad(
        self,
        customer_id: str,
        ad_group_id: str,
        ad_id: str,
        dry_run: bool = False
    ) -> Tuple[bool, str]:
        """
        Pausa un anuncio
        
        Args:
            customer_id: ID del cliente (sin guiones)
            ad_group_id: ID del ad group
            ad_id: ID del anuncio
            dry_run: Si es True, solo simula
            
        Returns:
            (success: bool, message: str)
        """
        try:
            # Construir resource name
            ad_resource_name = self.ad_group_ad_service.ad_group_ad_path(
                customer_id, ad_group_id, ad_id
            )
            
            if dry_run:
                logger.info(f"[DRY RUN] Pausar√≠a anuncio {ad_id} en ad group {ad_group_id}")
                return True, "[DRY RUN] Anuncio se pausar√≠a"
            
            # Crear operaci√≥n de actualizaci√≥n
            ad_group_ad_operation = self.client.get_type("AdGroupAdOperation")
            ad_group_ad = ad_group_ad_operation.update
            
            # Establecer resource name
            ad_group_ad.resource_name = ad_resource_name
            
            # Establecer status a PAUSED
            ad_group_ad.status = self.client.enums.AdGroupAdStatusEnum.PAUSED
            
            # Field mask para v21
            field_mask = field_mask_pb2.FieldMask(paths=["status"])
            ad_group_ad_operation.update_mask.CopyFrom(field_mask)
            
            # Ejecutar cambio
            response = self.ad_group_ad_service.mutate_ad_group_ads(
                customer_id=customer_id,
                operations=[ad_group_ad_operation]
            )
            
            logger.info(f"‚úÖ Anuncio pausado: ad_id {ad_id}")
            return True, "Anuncio pausado exitosamente"
            
        except GoogleAdsException as e:
            error_msg = f"Error API: {e.failure.errors[0].message}"
            logger.error(f"‚ùå {error_msg}")
            return False, error_msg
        except Exception as e:
            error_msg = f"Error inesperado: {str(e)}"
            logger.error(f"‚ùå {error_msg}", exc_info=True)
            return False, error_msg
    
    def enable_ad(
        self,
        customer_id: str,
        ad_group_id: str,
        ad_id: str,
        dry_run: bool = False
    ) -> Tuple[bool, str]:
        """
        Activa un anuncio pausado
        
        Args:
            customer_id: ID del cliente
            ad_group_id: ID del ad group
            ad_id: ID del anuncio
            dry_run: Si es True, solo simula
            
        Returns:
            (success: bool, message: str)
        """
        try:
            ad_resource_name = self.ad_group_ad_service.ad_group_ad_path(
                customer_id, ad_group_id, ad_id
            )
            
            if dry_run:
                logger.info(f"[DRY RUN] Activar√≠a anuncio {ad_id}")
                return True, "[DRY RUN] Anuncio se activar√≠a"
            
            ad_group_ad_operation = self.client.get_type("AdGroupAdOperation")
            ad_group_ad = ad_group_ad_operation.update
            
            ad_group_ad.resource_name = ad_resource_name
            ad_group_ad.status = self.client.enums.AdGroupAdStatusEnum.ENABLED
            
            field_mask = field_mask_pb2.FieldMask(paths=["status"])
            ad_group_ad_operation.update_mask.CopyFrom(field_mask)
            
            response = self.ad_group_ad_service.mutate_ad_group_ads(
                customer_id=customer_id,
                operations=[ad_group_ad_operation]
            )
            
            logger.info(f"‚úÖ Anuncio activado: ad_id {ad_id}")
            return True, "Anuncio activado exitosamente"
            
        except GoogleAdsException as e:
            error_msg = f"Error API: {e.failure.errors[0].message}"
            logger.error(f"‚ùå {error_msg}")
            return False, error_msg
        except Exception as e:
            error_msg = f"Error inesperado: {str(e)}"
            logger.error(f"‚ùå {error_msg}", exc_info=True)
            return False, error_msg
    
    def bulk_pause_ads(
        self,
        actions: List[AdAction],
        dry_run: bool = False
    ) -> Dict[str, any]:
        """
        Pausa m√∫ltiples anuncios en lote
        
        Args:
            actions: Lista de AdAction
            dry_run: Si es True, solo simula
            
        Returns:
            Diccionario con resultados
        """
        results = {
            'successful': 0,
            'failed': 0,
            'errors': [],
            'details': []
        }
        
        for action in actions:
            success, message = self.pause_ad(
                customer_id=action.customer_id,
                ad_group_id=action.ad_group_id,
                ad_id=action.ad_id,
                dry_run=dry_run
            )
            
            if success:
                results['successful'] += 1
            else:
                results['failed'] += 1
                results['errors'].append({
                    'ad_id': action.ad_id,
                    'headlines': action.ad_headlines,
                    'error': message
                })
            
            results['details'].append({
                'ad_id': action.ad_id,
                'headlines': action.ad_headlines,
                'campaign': action.campaign_name,
                'ad_group': action.ad_group_name,
                'previous_status': action.current_status,
                'reason': action.reason,
                'success': success,
                'message': message
            })
        
        logger.info(f"üìä Pausado de anuncios completado: {results['successful']} exitosos, {results['failed']} fallidos")
        return results
    
    def bulk_enable_ads(
        self,
        actions: List[AdAction],
        dry_run: bool = False
    ) -> Dict[str, any]:
        """
        Activa m√∫ltiples anuncios en lote
        
        Args:
            actions: Lista de AdAction
            dry_run: Si es True, solo simula
            
        Returns:
            Diccionario con resultados
        """
        results = {
            'successful': 0,
            'failed': 0,
            'errors': [],
            'details': []
        }
        
        for action in actions:
            success, message = self.enable_ad(
                customer_id=action.customer_id,
                ad_group_id=action.ad_group_id,
                ad_id=action.ad_id,
                dry_run=dry_run
            )
            
            if success:
                results['successful'] += 1
            else:
                results['failed'] += 1
                results['errors'].append({
                    'ad_id': action.ad_id,
                    'headlines': action.ad_headlines,
                    'error': message
                })
            
            results['details'].append({
                'ad_id': action.ad_id,
                'headlines': action.ad_headlines,
                'campaign': action.campaign_name,
                'ad_group': action.ad_group_name,
                'previous_status': action.current_status,
                'reason': action.reason,
                'success': success,
                'message': message
            })
        
        logger.info(f"üìä Activaci√≥n de anuncios completado: {results['successful']} exitosos, {results['failed']} fallidos")
        return results
üé® Paso 2: Agregar UI de Pausado en el Dashboard
En pages/8_üì¢_Ad_Health.py, agrega esta secci√≥n despu√©s de las recomendaciones:

Python
# ... (despu√©s de la secci√≥n de recomendaciones)

st.markdown("---")

# ===== AD MANAGEMENT SECTION =====
st.subheader("üéõÔ∏è Ad Management Actions")

if not df_filtered.empty:
    
    # Tabs para diferentes acciones
    action_tab1, action_tab2, action_tab3 = st.tabs([
        "‚è∏Ô∏è Pause Ads",
        "‚ñ∂Ô∏è Enable Ads",
        "üìä Bulk Actions"
    ])
    
    # ===== TAB 1: PAUSE ADS =====
    with action_tab1:
        st.markdown("#### ‚è∏Ô∏è Pause Underperforming Ads")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("##### üéØ Selection Criteria")
            
            pause_health_threshold = st.slider(
                "Max Health Score",
                min_value=0,
                max_value=50,
                value=30,
                help="Pause ads with health score below this value"
            )
            
            pause_min_spend = st.number_input(
                "Min Spend (to consider)",
                min_value=0.0,
                max_value=1000.0,
                value=50.0,
                step=10.0,
                help="Only consider ads that spent at least this amount"
            )
            
            pause_min_clicks = st.number_input(
                "Min Clicks (to consider)",
                min_value=0,
                max_value=500,
                value=30,
                help="Only consider ads with at least this many clicks"
            )
        
        with col2:
            st.markdown("##### üìã Ads to Pause")
            
            # Filter ads that meet pause criteria
            ads_to_pause = df_filtered[
                (df_filtered['health_score'] < pause_health_threshold) &
                (df_filtered['spend'] >= pause_min_spend) &
                (df_filtered['clicks'] >= pause_min_clicks) &
                (df_filtered['ad_status'] == 'ENABLED')
            ].copy()
            
            if not ads_to_pause.empty:
                st.metric("Ads Selected", len(ads_to_pause))
                st.metric("Total Spend", f"${ads_to_pause['spend'].sum():.2f}")
                st.metric("Total Conversions", f"{ads_to_pause['conversions'].sum():.0f}")
                
                # Preview
                with st.expander("üëÅÔ∏è Preview Ads to Pause"):
                    preview_pause = ads_to_pause[[
                        'ad_id', 'headlines', 'campaign_name', 'health_score', 
                        'spend', 'conversions'
                    ]].head(10).copy()
                    preview_pause['headlines'] = preview_pause['headlines'].apply(format_headlines)
                    st.dataframe(preview_pause, use_container_width=True)
                    if len(ads_to_pause) > 10:
                        st.caption(f"... and {len(ads_to_pause) - 10} more")
            else:
                st.info("No ads meet the pause criteria")
        
        # Execution controls
        if not ads_to_pause.empty:
            st.markdown("---")
            st.markdown("##### ‚öôÔ∏è Execution Mode")
            
            col1, col2 = st.columns([1, 2])
            
            with col1:
                dry_run_pause = st.checkbox(
                    "üß™ Dry Run Mode",
                    value=True,
                    help="Simulate without actually pausing",
                    key="dry_run_pause"
                )
            
            with col2:
                confirm_pause = st.checkbox(
                    "‚úÖ I confirm I want to pause these ads",
                    value=False,
                    help="Required to enable execution",
                    key="confirm_pause"
                )
            
            # Execute button
            col1, col2, col3 = st.columns([1, 1, 1])
            with col2:
                execute_pause = st.button(
                    "‚è∏Ô∏è Pause Selected Ads" if not dry_run_pause else "üß™ Simulate Pause",
                    disabled=not dry_run_pause and not confirm_pause,
                    use_container_width=True,
                    type="primary",
                    key="execute_pause_btn"
                )
            
            if execute_pause:
                # Import service
                from services.ad_management_service import AdManagementService, AdAction
                
                try:
                    # Initialize service
                    ad_mgmt_service = AdManagementService(st.session_state.google_ads_client)
                    
                    # Prepare actions
                    actions = []
                    for _, row in ads_to_pause.iterrows():
                        actions.append(AdAction(
                            customer_id=selected_customer,
                            ad_group_id=str(row['ad_group_id']),
                            ad_id=str(row['ad_id']),
                            ad_headlines=format_headlines(row['headlines']),
                            campaign_name=row['campaign_name'],
                            ad_group_name=row['ad_group_name'],
                            current_status=row['ad_status'],
                            reason=f"Health Score: {row['health_score']:.1f}, Spend: ${row['spend']:.2f}, Conv: {row['conversions']:.0f}"
                        ))
                    
                    # Execute
                    with st.spinner(f"‚è≥ {'Simulating' if dry_run_pause else 'Pausing'} {len(actions)} ads..."):
                        results = ad_mgmt_service.bulk_pause_ads(actions, dry_run=dry_run_pause)
                    
                    # Show results
                    if dry_run_pause:
                        st.info(f"üß™ **Simulation completed** - No real changes made")
                    else:
                        st.success(f"‚úÖ **Ads paused successfully**")
                    
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("Successful", results['successful'])
                    with col2:
                        st.metric("Failed", results['failed'])
                    with col3:
                        st.metric("Total", len(actions))
                    
                    # Details
                    with st.expander("üìã View Details"):
                        details_df = pd.DataFrame(results['details'])
                        st.dataframe(details_df, use_container_width=True)
                    
                    # Errors
                    if results['errors']:
                        with st.expander("‚ö†Ô∏è View Errors"):
                            for error in results['errors']:
                                st.error(f"**{error['headlines']}** (ID: {error['ad_id']}): {error['error']}")
                
                except Exception as e:
                    st.error(f"‚ùå Error executing pause action: {e}")
                    logger.error(f"Error in pause execution: {e}", exc_info=True)
    
    # ===== TAB 2: ENABLE ADS =====
    with action_tab2:
        st.markdown("#### ‚ñ∂Ô∏è Enable Paused Ads")
        
        # Filter paused ads
        paused_ads = df_filtered[df_filtered['ad_status'] == 'PAUSED'].copy()
        
        if not paused_ads.empty:
            st.write(f"**Found {len(paused_ads)} paused ads**")
            
            # Selection
            ads_to_enable = st.multiselect(
                "Select ads to enable",
                options=paused_ads['ad_id'].tolist(),
                format_func=lambda x: format_headlines(
                    paused_ads[paused_ads['ad_id'] == x]['headlines'].iloc[0]
                )
            )
            
            if ads_to_enable:
                selected_ads = paused_ads[paused_ads['ad_id'].isin(ads_to_enable)]
                
                st.write(f"**{len(selected_ads)} ads selected**")
                
                with st.expander("üëÅÔ∏è Preview"):
                    preview_enable = selected_ads[[
                        'ad_id', 'headlines', 'campaign_name', 'health_score'
                    ]].copy()
                    preview_enable['headlines'] = preview_enable['headlines'].apply(format_headlines)
                    st.dataframe(preview_enable, use_container_width=True)
                
                # Execute
                if st.button("‚ñ∂Ô∏è Enable Selected Ads", type="primary", key="execute_enable_btn"):
                    from services.ad_management_service import AdManagementService, AdAction
                    
                    try:
                        ad_mgmt_service = AdManagementService(st.session_state.google_ads_client)
                        
                        actions = []
                        for _, row in selected_ads.iterrows():
                            actions.append(AdAction(
                                customer_id=selected_customer,
                                ad_group_id=str(row['ad_group_id']),
                                ad_id=str(row['ad_id']),
                                ad_headlines=format_headlines(row['headlines']),
                                campaign_name=row['campaign_name'],
                                ad_group_name=row['ad_group_name'],
                                current_status=row['ad_status'],
                                reason="Manual enable from dashboard"
                            ))
                        
                        with st.spinner(f"‚è≥ Enabling {len(actions)} ads..."):
                            results = ad_mgmt_service.bulk_enable_ads(actions, dry_run=False)
                        
                        st.success(f"‚úÖ {results['successful']} ads enabled successfully")
                        
                        if results['failed'] > 0:
                            st.error(f"‚ùå {results['failed']} ads failed to enable")
                            with st.expander("View Errors"):
                                for error in results['errors']:
                                    st.write(f"- {error['headlines']}: {error['error']}")
                        
                        # Refresh data
                        st.cache_data.clear()
                        st.rerun()
                    
                    except Exception as e:
                        st.error(f"‚ùå Error: {e}")
                        logger.error(f"Error enabling ads: {e}", exc_info=True)
        else:
            st.info("No paused ads found in the current selection")
    
    # ===== TAB 3: BULK ACTIONS =====
    with action_tab3:
        st.markdown("#### üìä Bulk Actions by Category")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("##### üßõ Pause All Vampires")
            vampires = ad_health_service.get_vampire_ads(df_filtered)
            vampires_enabled = vampires[vampires['ad_status'] == 'ENABLED']
            
            if not vampires_enabled.empty:
                st.write(f"**{len(vampires_enabled)} vampire ads found**")
                st.metric("Total Wasted Spend", f"${vampires_enabled['spend'].sum():.2f}")
                
                if st.button("‚è∏Ô∏è Pause All Vampires", key="pause_vampires_btn"):
                    from services.ad_management_service import AdManagementService, AdAction
                    
                    ad_mgmt_service = AdManagementService(st.session_state.google_ads_client)
                    
                    actions = []
                    for _, row in vampires_enabled.iterrows():
                        actions.append(AdAction(
                            customer_id=selected_customer,
                            ad_group_id=str(row['ad_group_id']),
                            ad_id=str(row['ad_id']),
                            ad_headlines=format_headlines(row['headlines']),
                            campaign_name=row['campaign_name'],
                            ad_group_name=row['ad_group_name'],
                            current_status=row['ad_status'],
                            reason="Vampire ad: high spend, 0 conversions"
                        ))
                    
                    with st.spinner("Pausing vampire ads..."):
                        results = ad_mgmt_service.bulk_pause_ads(actions, dry_run=False)
                    
                    st.success(f"‚úÖ {results['successful']} vampire ads paused")
                    st.cache_data.clear()
                    st.rerun()
            else:
                st.info("No vampire ads found")
        
        with col2:
            st.markdown("##### ‚ö†Ô∏è Pause Policy Issues")
            policy_issues = ad_health_service.get_policy_issues(df_filtered)
            policy_enabled = policy_issues[
                (policy_issues['ad_status'] == 'ENABLED') &
                (policy_issues['approval_status'] == 'DISAPPROVED')
            ]
            
            if not policy_enabled.empty:
                st.write(f"**{len(policy_enabled)} disapproved ads still enabled**")
                
                if st.button("‚è∏Ô∏è Pause Disapproved Ads", key="pause_policy_btn"):
                    from services.ad_management_service import AdManagementService, AdAction
                    
                    ad_mgmt_service = AdManagementService(st.session_state.google_ads_client)
                    
                    actions = []
                    for _, row in policy_enabled.iterrows():
                        actions.append(AdAction(
                            customer_id=selected_customer,
                            ad_group_id=str(row['ad_group_id']),
                            ad_id=str(row['ad_id']),
                            ad_headlines=format_headlines(row['headlines']),
                            campaign_name=row['campaign_name'],
                            ad_group_name=row['ad_group_name'],
                            current_status=row['ad_status'],
                            reason="Disapproved by policy"
                        ))
                    
                    with st.spinner("Pausing disapproved ads..."):
                        results = ad_mgmt_service.bulk_pause_ads(actions, dry_run=False)
                    
                    st.success(f"‚úÖ {results['successful']} disapproved ads paused")
                    st.cache_data.clear()
                    st.rerun()
            else:
                st.info("No disapproved ads found")

else:
    st.info("No ads available for management actions")
üéØ Resultado Final
Ahora tendr√°s 3 pesta√±as en la secci√≥n de Ad Management:

1. ‚è∏Ô∏è Pause Ads
Sliders para definir criterios (health score, spend, clicks)
Preview de anuncios a pausar
Modo dry-run
Confirmaci√≥n requerida
Reporte detallado de √©xitos/errores
2. ‚ñ∂Ô∏è Enable Ads
Lista de anuncios pausados
Selecci√≥n m√∫ltiple
Activaci√≥n instant√°nea
3. üìä Bulk Actions
Pausar todos los vampiros con 1 click
Pausar anuncios rechazados con 1 click
Acciones r√°pidas para categor√≠as completas
‚úÖ Features Implementadas
Feature	Status
Pausar anuncios individuales	‚úÖ
Pausar en lote con criterios	‚úÖ
Activar anuncios pausados	‚úÖ
Modo dry-run (simulaci√≥n)	‚úÖ
Confirmaci√≥n obligatoria	‚úÖ
Reporte de √©xitos/errores	‚úÖ
Pausar vampiros con 1 click	‚úÖ
Pausar rechazados con 1 click	‚úÖ
Compatible con API v21	‚úÖ
Compatible con COP	‚úÖ
üöÄ Para Usar
Copia services/ad_management_service.py
Agrega la secci√≥n de Ad Management al dashboard
Reinicia Streamlit
Navega a üì¢ Ad Health
Scroll down a "üéõÔ∏è Ad Management Actions"
Prueba con Dry Run primero
Ejecuta pausas reales cuando est√©s seguro
