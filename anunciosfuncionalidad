Copilot said: # ⏸️ **Funcionalidad: Pausar Anuncios vía API** Vamos
⏸️ Funcionalidad: Pausar Anuncios vía API
Vamos a agregar la capacidad de pausar anuncios directamente desde el dashboard, similar a cómo hicimos con los ajustes de pujas en keywords.

🏗️ Arquitectura de la Solución
Code
1. Usuario selecciona anuncios vampiro/críticos
2. Click en botón "Pausar Seleccionados"
3. Confirmación (evitar pausas accidentales)
4. API de Google Ads pausa los anuncios
5. Feedback visual de éxito/errores
🔧 Paso 1: Crear services/ad_management_service.py
Python
"""
Ad Management Service - Gestiona acciones sobre anuncios (pausar, activar, etc.)
Compatible con Google Ads API v21
"""

from google.ads.googleads.client import GoogleAdsClient
from google.ads.googleads.errors import GoogleAdsException
from google.protobuf import field_mask_pb2
from typing import List, Dict, Tuple
import logging
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class AdAction:
    """Representa una acción sobre un anuncio"""
    customer_id: str
    ad_group_id: str
    ad_id: str
    ad_headlines: str
    campaign_name: str
    ad_group_name: str
    current_status: str
    reason: str

class AdManagementService:
    """Servicio para gestionar acciones sobre anuncios"""
    
    def __init__(self, google_ads_client):
        """
        Inicializa el servicio
        
        Args:
            google_ads_client: GoogleAdsClient o GoogleAdsClientWrapper
        """
        # Detectar si es wrapper y extraer cliente real
        if hasattr(google_ads_client, 'client'):
            self.client = google_ads_client.client
            logger.info("Usando cliente real extraído de GoogleAdsClientWrapper")
        else:
            self.client = google_ads_client
            logger.info("Usando GoogleAdsClient directo")
        
        # Inicializar servicios
        try:
            self.ad_group_ad_service = self.client.get_service("AdGroupAdService")
            self.googleads_service = self.client.get_service("GoogleAdsService")
            logger.info("✅ AdManagementService inicializado correctamente")
        except Exception as e:
            logger.error(f"❌ Error inicializando servicios: {e}")
            raise
    
    def pause_ad(
        self,
        customer_id: str,
        ad_group_id: str,
        ad_id: str,
        dry_run: bool = False
    ) -> Tuple[bool, str]:
        """
        Pausa un anuncio
        
        Args:
            customer_id: ID del cliente (sin guiones)
            ad_group_id: ID del ad group
            ad_id: ID del anuncio
            dry_run: Si es True, solo simula
            
        Returns:
            (success: bool, message: str)
        """
        try:
            # Construir resource name
            ad_resource_name = self.ad_group_ad_service.ad_group_ad_path(
                customer_id, ad_group_id, ad_id
            )
            
            if dry_run:
                logger.info(f"[DRY RUN] Pausaría anuncio {ad_id} en ad group {ad_group_id}")
                return True, "[DRY RUN] Anuncio se pausaría"
            
            # Crear operación de actualización
            ad_group_ad_operation = self.client.get_type("AdGroupAdOperation")
            ad_group_ad = ad_group_ad_operation.update
            
            # Establecer resource name
            ad_group_ad.resource_name = ad_resource_name
            
            # Establecer status a PAUSED
            ad_group_ad.status = self.client.enums.AdGroupAdStatusEnum.PAUSED
            
            # Field mask para v21
            field_mask = field_mask_pb2.FieldMask(paths=["status"])
            ad_group_ad_operation.update_mask.CopyFrom(field_mask)
            
            # Ejecutar cambio
            response = self.ad_group_ad_service.mutate_ad_group_ads(
                customer_id=customer_id,
                operations=[ad_group_ad_operation]
            )
            
            logger.info(f"✅ Anuncio pausado: ad_id {ad_id}")
            return True, "Anuncio pausado exitosamente"
            
        except GoogleAdsException as e:
            error_msg = f"Error API: {e.failure.errors[0].message}"
            logger.error(f"❌ {error_msg}")
            return False, error_msg
        except Exception as e:
            error_msg = f"Error inesperado: {str(e)}"
            logger.error(f"❌ {error_msg}", exc_info=True)
            return False, error_msg
    
    def enable_ad(
        self,
        customer_id: str,
        ad_group_id: str,
        ad_id: str,
        dry_run: bool = False
    ) -> Tuple[bool, str]:
        """
        Activa un anuncio pausado
        
        Args:
            customer_id: ID del cliente
            ad_group_id: ID del ad group
            ad_id: ID del anuncio
            dry_run: Si es True, solo simula
            
        Returns:
            (success: bool, message: str)
        """
        try:
            ad_resource_name = self.ad_group_ad_service.ad_group_ad_path(
                customer_id, ad_group_id, ad_id
            )
            
            if dry_run:
                logger.info(f"[DRY RUN] Activaría anuncio {ad_id}")
                return True, "[DRY RUN] Anuncio se activaría"
            
            ad_group_ad_operation = self.client.get_type("AdGroupAdOperation")
            ad_group_ad = ad_group_ad_operation.update
            
            ad_group_ad.resource_name = ad_resource_name
            ad_group_ad.status = self.client.enums.AdGroupAdStatusEnum.ENABLED
            
            field_mask = field_mask_pb2.FieldMask(paths=["status"])
            ad_group_ad_operation.update_mask.CopyFrom(field_mask)
            
            response = self.ad_group_ad_service.mutate_ad_group_ads(
                customer_id=customer_id,
                operations=[ad_group_ad_operation]
            )
            
            logger.info(f"✅ Anuncio activado: ad_id {ad_id}")
            return True, "Anuncio activado exitosamente"
            
        except GoogleAdsException as e:
            error_msg = f"Error API: {e.failure.errors[0].message}"
            logger.error(f"❌ {error_msg}")
            return False, error_msg
        except Exception as e:
            error_msg = f"Error inesperado: {str(e)}"
            logger.error(f"❌ {error_msg}", exc_info=True)
            return False, error_msg
    
    def bulk_pause_ads(
        self,
        actions: List[AdAction],
        dry_run: bool = False
    ) -> Dict[str, any]:
        """
        Pausa múltiples anuncios en lote
        
        Args:
            actions: Lista de AdAction
            dry_run: Si es True, solo simula
            
        Returns:
            Diccionario con resultados
        """
        results = {
            'successful': 0,
            'failed': 0,
            'errors': [],
            'details': []
        }
        
        for action in actions:
            success, message = self.pause_ad(
                customer_id=action.customer_id,
                ad_group_id=action.ad_group_id,
                ad_id=action.ad_id,
                dry_run=dry_run
            )
            
            if success:
                results['successful'] += 1
            else:
                results['failed'] += 1
                results['errors'].append({
                    'ad_id': action.ad_id,
                    'headlines': action.ad_headlines,
                    'error': message
                })
            
            results['details'].append({
                'ad_id': action.ad_id,
                'headlines': action.ad_headlines,
                'campaign': action.campaign_name,
                'ad_group': action.ad_group_name,
                'previous_status': action.current_status,
                'reason': action.reason,
                'success': success,
                'message': message
            })
        
        logger.info(f"📊 Pausado de anuncios completado: {results['successful']} exitosos, {results['failed']} fallidos")
        return results
    
    def bulk_enable_ads(
        self,
        actions: List[AdAction],
        dry_run: bool = False
    ) -> Dict[str, any]:
        """
        Activa múltiples anuncios en lote
        
        Args:
            actions: Lista de AdAction
            dry_run: Si es True, solo simula
            
        Returns:
            Diccionario con resultados
        """
        results = {
            'successful': 0,
            'failed': 0,
            'errors': [],
            'details': []
        }
        
        for action in actions:
            success, message = self.enable_ad(
                customer_id=action.customer_id,
                ad_group_id=action.ad_group_id,
                ad_id=action.ad_id,
                dry_run=dry_run
            )
            
            if success:
                results['successful'] += 1
            else:
                results['failed'] += 1
                results['errors'].append({
                    'ad_id': action.ad_id,
                    'headlines': action.ad_headlines,
                    'error': message
                })
            
            results['details'].append({
                'ad_id': action.ad_id,
                'headlines': action.ad_headlines,
                'campaign': action.campaign_name,
                'ad_group': action.ad_group_name,
                'previous_status': action.current_status,
                'reason': action.reason,
                'success': success,
                'message': message
            })
        
        logger.info(f"📊 Activación de anuncios completado: {results['successful']} exitosos, {results['failed']} fallidos")
        return results
🎨 Paso 2: Agregar UI de Pausado en el Dashboard
En pages/8_📢_Ad_Health.py, agrega esta sección después de las recomendaciones:

Python
# ... (después de la sección de recomendaciones)

st.markdown("---")

# ===== AD MANAGEMENT SECTION =====
st.subheader("🎛️ Ad Management Actions")

if not df_filtered.empty:
    
    # Tabs para diferentes acciones
    action_tab1, action_tab2, action_tab3 = st.tabs([
        "⏸️ Pause Ads",
        "▶️ Enable Ads",
        "📊 Bulk Actions"
    ])
    
    # ===== TAB 1: PAUSE ADS =====
    with action_tab1:
        st.markdown("#### ⏸️ Pause Underperforming Ads")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("##### 🎯 Selection Criteria")
            
            pause_health_threshold = st.slider(
                "Max Health Score",
                min_value=0,
                max_value=50,
                value=30,
                help="Pause ads with health score below this value"
            )
            
            pause_min_spend = st.number_input(
                "Min Spend (to consider)",
                min_value=0.0,
                max_value=1000.0,
                value=50.0,
                step=10.0,
                help="Only consider ads that spent at least this amount"
            )
            
            pause_min_clicks = st.number_input(
                "Min Clicks (to consider)",
                min_value=0,
                max_value=500,
                value=30,
                help="Only consider ads with at least this many clicks"
            )
        
        with col2:
            st.markdown("##### 📋 Ads to Pause")
            
            # Filter ads that meet pause criteria
            ads_to_pause = df_filtered[
                (df_filtered['health_score'] < pause_health_threshold) &
                (df_filtered['spend'] >= pause_min_spend) &
                (df_filtered['clicks'] >= pause_min_clicks) &
                (df_filtered['ad_status'] == 'ENABLED')
            ].copy()
            
            if not ads_to_pause.empty:
                st.metric("Ads Selected", len(ads_to_pause))
                st.metric("Total Spend", f"${ads_to_pause['spend'].sum():.2f}")
                st.metric("Total Conversions", f"{ads_to_pause['conversions'].sum():.0f}")
                
                # Preview
                with st.expander("👁️ Preview Ads to Pause"):
                    preview_pause = ads_to_pause[[
                        'ad_id', 'headlines', 'campaign_name', 'health_score', 
                        'spend', 'conversions'
                    ]].head(10).copy()
                    preview_pause['headlines'] = preview_pause['headlines'].apply(format_headlines)
                    st.dataframe(preview_pause, use_container_width=True)
                    if len(ads_to_pause) > 10:
                        st.caption(f"... and {len(ads_to_pause) - 10} more")
            else:
                st.info("No ads meet the pause criteria")
        
        # Execution controls
        if not ads_to_pause.empty:
            st.markdown("---")
            st.markdown("##### ⚙️ Execution Mode")
            
            col1, col2 = st.columns([1, 2])
            
            with col1:
                dry_run_pause = st.checkbox(
                    "🧪 Dry Run Mode",
                    value=True,
                    help="Simulate without actually pausing",
                    key="dry_run_pause"
                )
            
            with col2:
                confirm_pause = st.checkbox(
                    "✅ I confirm I want to pause these ads",
                    value=False,
                    help="Required to enable execution",
                    key="confirm_pause"
                )
            
            # Execute button
            col1, col2, col3 = st.columns([1, 1, 1])
            with col2:
                execute_pause = st.button(
                    "⏸️ Pause Selected Ads" if not dry_run_pause else "🧪 Simulate Pause",
                    disabled=not dry_run_pause and not confirm_pause,
                    use_container_width=True,
                    type="primary",
                    key="execute_pause_btn"
                )
            
            if execute_pause:
                # Import service
                from services.ad_management_service import AdManagementService, AdAction
                
                try:
                    # Initialize service
                    ad_mgmt_service = AdManagementService(st.session_state.google_ads_client)
                    
                    # Prepare actions
                    actions = []
                    for _, row in ads_to_pause.iterrows():
                        actions.append(AdAction(
                            customer_id=selected_customer,
                            ad_group_id=str(row['ad_group_id']),
                            ad_id=str(row['ad_id']),
                            ad_headlines=format_headlines(row['headlines']),
                            campaign_name=row['campaign_name'],
                            ad_group_name=row['ad_group_name'],
                            current_status=row['ad_status'],
                            reason=f"Health Score: {row['health_score']:.1f}, Spend: ${row['spend']:.2f}, Conv: {row['conversions']:.0f}"
                        ))
                    
                    # Execute
                    with st.spinner(f"⏳ {'Simulating' if dry_run_pause else 'Pausing'} {len(actions)} ads..."):
                        results = ad_mgmt_service.bulk_pause_ads(actions, dry_run=dry_run_pause)
                    
                    # Show results
                    if dry_run_pause:
                        st.info(f"🧪 **Simulation completed** - No real changes made")
                    else:
                        st.success(f"✅ **Ads paused successfully**")
                    
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("Successful", results['successful'])
                    with col2:
                        st.metric("Failed", results['failed'])
                    with col3:
                        st.metric("Total", len(actions))
                    
                    # Details
                    with st.expander("📋 View Details"):
                        details_df = pd.DataFrame(results['details'])
                        st.dataframe(details_df, use_container_width=True)
                    
                    # Errors
                    if results['errors']:
                        with st.expander("⚠️ View Errors"):
                            for error in results['errors']:
                                st.error(f"**{error['headlines']}** (ID: {error['ad_id']}): {error['error']}")
                
                except Exception as e:
                    st.error(f"❌ Error executing pause action: {e}")
                    logger.error(f"Error in pause execution: {e}", exc_info=True)
    
    # ===== TAB 2: ENABLE ADS =====
    with action_tab2:
        st.markdown("#### ▶️ Enable Paused Ads")
        
        # Filter paused ads
        paused_ads = df_filtered[df_filtered['ad_status'] == 'PAUSED'].copy()
        
        if not paused_ads.empty:
            st.write(f"**Found {len(paused_ads)} paused ads**")
            
            # Selection
            ads_to_enable = st.multiselect(
                "Select ads to enable",
                options=paused_ads['ad_id'].tolist(),
                format_func=lambda x: format_headlines(
                    paused_ads[paused_ads['ad_id'] == x]['headlines'].iloc[0]
                )
            )
            
            if ads_to_enable:
                selected_ads = paused_ads[paused_ads['ad_id'].isin(ads_to_enable)]
                
                st.write(f"**{len(selected_ads)} ads selected**")
                
                with st.expander("👁️ Preview"):
                    preview_enable = selected_ads[[
                        'ad_id', 'headlines', 'campaign_name', 'health_score'
                    ]].copy()
                    preview_enable['headlines'] = preview_enable['headlines'].apply(format_headlines)
                    st.dataframe(preview_enable, use_container_width=True)
                
                # Execute
                if st.button("▶️ Enable Selected Ads", type="primary", key="execute_enable_btn"):
                    from services.ad_management_service import AdManagementService, AdAction
                    
                    try:
                        ad_mgmt_service = AdManagementService(st.session_state.google_ads_client)
                        
                        actions = []
                        for _, row in selected_ads.iterrows():
                            actions.append(AdAction(
                                customer_id=selected_customer,
                                ad_group_id=str(row['ad_group_id']),
                                ad_id=str(row['ad_id']),
                                ad_headlines=format_headlines(row['headlines']),
                                campaign_name=row['campaign_name'],
                                ad_group_name=row['ad_group_name'],
                                current_status=row['ad_status'],
                                reason="Manual enable from dashboard"
                            ))
                        
                        with st.spinner(f"⏳ Enabling {len(actions)} ads..."):
                            results = ad_mgmt_service.bulk_enable_ads(actions, dry_run=False)
                        
                        st.success(f"✅ {results['successful']} ads enabled successfully")
                        
                        if results['failed'] > 0:
                            st.error(f"❌ {results['failed']} ads failed to enable")
                            with st.expander("View Errors"):
                                for error in results['errors']:
                                    st.write(f"- {error['headlines']}: {error['error']}")
                        
                        # Refresh data
                        st.cache_data.clear()
                        st.rerun()
                    
                    except Exception as e:
                        st.error(f"❌ Error: {e}")
                        logger.error(f"Error enabling ads: {e}", exc_info=True)
        else:
            st.info("No paused ads found in the current selection")
    
    # ===== TAB 3: BULK ACTIONS =====
    with action_tab3:
        st.markdown("#### 📊 Bulk Actions by Category")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("##### 🧛 Pause All Vampires")
            vampires = ad_health_service.get_vampire_ads(df_filtered)
            vampires_enabled = vampires[vampires['ad_status'] == 'ENABLED']
            
            if not vampires_enabled.empty:
                st.write(f"**{len(vampires_enabled)} vampire ads found**")
                st.metric("Total Wasted Spend", f"${vampires_enabled['spend'].sum():.2f}")
                
                if st.button("⏸️ Pause All Vampires", key="pause_vampires_btn"):
                    from services.ad_management_service import AdManagementService, AdAction
                    
                    ad_mgmt_service = AdManagementService(st.session_state.google_ads_client)
                    
                    actions = []
                    for _, row in vampires_enabled.iterrows():
                        actions.append(AdAction(
                            customer_id=selected_customer,
                            ad_group_id=str(row['ad_group_id']),
                            ad_id=str(row['ad_id']),
                            ad_headlines=format_headlines(row['headlines']),
                            campaign_name=row['campaign_name'],
                            ad_group_name=row['ad_group_name'],
                            current_status=row['ad_status'],
                            reason="Vampire ad: high spend, 0 conversions"
                        ))
                    
                    with st.spinner("Pausing vampire ads..."):
                        results = ad_mgmt_service.bulk_pause_ads(actions, dry_run=False)
                    
                    st.success(f"✅ {results['successful']} vampire ads paused")
                    st.cache_data.clear()
                    st.rerun()
            else:
                st.info("No vampire ads found")
        
        with col2:
            st.markdown("##### ⚠️ Pause Policy Issues")
            policy_issues = ad_health_service.get_policy_issues(df_filtered)
            policy_enabled = policy_issues[
                (policy_issues['ad_status'] == 'ENABLED') &
                (policy_issues['approval_status'] == 'DISAPPROVED')
            ]
            
            if not policy_enabled.empty:
                st.write(f"**{len(policy_enabled)} disapproved ads still enabled**")
                
                if st.button("⏸️ Pause Disapproved Ads", key="pause_policy_btn"):
                    from services.ad_management_service import AdManagementService, AdAction
                    
                    ad_mgmt_service = AdManagementService(st.session_state.google_ads_client)
                    
                    actions = []
                    for _, row in policy_enabled.iterrows():
                        actions.append(AdAction(
                            customer_id=selected_customer,
                            ad_group_id=str(row['ad_group_id']),
                            ad_id=str(row['ad_id']),
                            ad_headlines=format_headlines(row['headlines']),
                            campaign_name=row['campaign_name'],
                            ad_group_name=row['ad_group_name'],
                            current_status=row['ad_status'],
                            reason="Disapproved by policy"
                        ))
                    
                    with st.spinner("Pausing disapproved ads..."):
                        results = ad_mgmt_service.bulk_pause_ads(actions, dry_run=False)
                    
                    st.success(f"✅ {results['successful']} disapproved ads paused")
                    st.cache_data.clear()
                    st.rerun()
            else:
                st.info("No disapproved ads found")

else:
    st.info("No ads available for management actions")
🎯 Resultado Final
Ahora tendrás 3 pestañas en la sección de Ad Management:

1. ⏸️ Pause Ads
Sliders para definir criterios (health score, spend, clicks)
Preview de anuncios a pausar
Modo dry-run
Confirmación requerida
Reporte detallado de éxitos/errores
2. ▶️ Enable Ads
Lista de anuncios pausados
Selección múltiple
Activación instantánea
3. 📊 Bulk Actions
Pausar todos los vampiros con 1 click
Pausar anuncios rechazados con 1 click
Acciones rápidas para categorías completas
✅ Features Implementadas
Feature	Status
Pausar anuncios individuales	✅
Pausar en lote con criterios	✅
Activar anuncios pausados	✅
Modo dry-run (simulación)	✅
Confirmación obligatoria	✅
Reporte de éxitos/errores	✅
Pausar vampiros con 1 click	✅
Pausar rechazados con 1 click	✅
Compatible con API v21	✅
Compatible con COP	✅
🚀 Para Usar
Copia services/ad_management_service.py
Agrega la sección de Ad Management al dashboard
Reinicia Streamlit
Navega a 📢 Ad Health
Scroll down a "🎛️ Ad Management Actions"
Prueba con Dry Run primero
Ejecuta pausas reales cuando estés seguro
